<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Technical Overview
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="description" content="A general-purpose serialization library for .NET"/>
    <meta name="author" content="Eirik Tsarpalis"/>

    <script src="https://code.jquery.com/jquery-1.8.0.js"></script>
    <script src="https://code.jquery.com/ui/1.8.23/jquery-ui.js"></script>
    <script src="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/js/bootstrap.min.js"></script>
    <link href="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/css/bootstrap-combined.min.css" rel="stylesheet"/>

    <link type="text/css" rel="stylesheet" href="/FsPickler/content/style.css" />
    <script type="text/javascript" src="/FsPickler/content/tips.js"></script>
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="https://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="container">
      <div class="masthead">
        <ul class="nav nav-pills pull-right">
          <li><a href="http://fsharp.org">fsharp.org</a></li>
          <li><a href="http://github.com/nessos/FsPickler">github page</a></li>
        </ul>
        <h3 class="muted"><a href="/FsPickler/index.html">FsPickler</a></h3>
      </div>
      <hr />
      <div class="row">
        <div class="span9" id="main">
          
<h1>Technical Overview</h1>

<p>This article discusses the general topic of serialization in .NET
and gives an overview of the implementation details in FsPickler.</p>

<h2>Serialization in the .NET framework</h2>

<p>Serialization in the .NET framework is something often considered
as being problematic or even broken. This is mainly for the following reasons:</p>

<ul>
<li><p>There is no type or runtime support for serialization. 
Rather, serializers are library implementations that mostly depend
on the reflection system to extrapolate serialization rules for
each type (resulting in runtime errors if this is not possible).</p></li>
<li><p>There is confusion as to which is the prefered methodology for serialization.
The BCL comes with a multitude of dated, unsafe, mutually exclusive
and naturally inefficient patterns.</p></li>
</ul>

<h3>BCL Serialization methods</h3>

<p>The BCL comes with the following patterns for defining serializable types:</p>

<ul>
<li><p>Field-based serialization: objects are pickled by serializing the contents 
of their fields. This behaviour is tuned by applying an assortment of attributes
such as <code>Serialized</code>, <code>NonSerialized</code>, <code>OnSerializing</code>, <code>OnDeserialized</code>, etc and
implementing the <code>IDeserializationCallback</code> interface. This is arguably the most
loathed method, since it is sensitive to internal implementation details.
Incidentally, this is the pattern of choice for most F# generated types.</p></li>
<li><p>Property-based or <a href="http://msdn.microsoft.com/en-us/library/ms733127.aspx">DataContract</a> 
serialization: objects are pickled by serializing the contents
of specially flagged properties. Properties should be settable and are usually required to be
public. In most cases, a parameterless constructor is also necessary. Property-based serialization
is probably the most popular pattern.</p></li>
<li><p><a href="http://msdn.microsoft.com/en-us/library/system.runtime.serialization.iserializable.aspx">ISerializable</a> 
types: possibly intended as a type-safe replacement of field-based serialization.
It fails to live up to this role, mostly due to the nature of interfaces; it still requires a
special constructor for deserialization which, if missing, would result in a runtime error.
It is a particularly verbose pattern, resulting in a lot of boilerplate code.
Its dynamic nature also makes it impossible to reason about the components it serializes a priori.
It is however an indispensible pattern, since it is used by many BCL types, most important being
exception types, whose metadata is impossible to replicate without <code>ISerializable</code>.</p></li>
</ul>

<h3>Serialization Libraries</h3>

<p>The BCL ships with a couple of general-purpose serializer libraries but these suffer either
from obsolescence (e.g. <a href="http://msdn.microsoft.com/en-us/library/system.runtime.serialization.formatters.binary.binaryformatter.aspx">BinaryFormatter</a>) 
or performance (<a href="http://msdn.microsoft.com/en-us/library/system.runtime.serialization.netdatacontractserializer.aspx">NetDataContractSerializer</a>).</p>

<p>Many third-party libraries have emerged attempting to address the issue of performance, some with success.
However, experience shows that such libraries hardly achieve the level of generalization
offered by their BCL counterparts. In particular most of them:</p>

<ul>
<li><p>offer sketchy or no support for reflection types, like <code>MemberInfo</code>.</p></li>
<li><p>require library-specific dependencies for serializable type definitions.</p></li>
<li><p>do not support inaccessible types/constructors/properties.</p></li>
<li><p>fail to address subtype polymorphism.</p></li>
<li><p>do not support types like multi-dimensional arrays or delegates.</p></li>
<li><p>fail to properly handle cyclic objects.</p></li>
<li><p>have limited or nonexistent support for F# types.</p></li>
</ul>

<h2>FsPickler : Motivation</h2>

<p>The need for a new serialization library was realized while developing for 
<a href="http://nessos.github.io/MBrace/">MBrace</a>. MBrace is a framework for distributed
computation and big data that is essentially built on the idea of a distributed
continuation monad. To be able to distribute continuations, you need to be able to
serialize closures. The inherently intrinsic and arbitrary nature of closures means 
that they are not supported by most serialization libraries.
Initially we started using NetDataContractSerializer as our library of choice,
but that eventually took its toll on overall performance,
so we decided to build a new library from scratch.</p>

<p>FsPickler was created with two goals in mind: performance and completeness.
Importantly, it was conceived as a .NET serializer, rather than an F# serializer:
if it is a .NET object designed to be serialized, it should be serializable in FsPickler.
In that sense, it was designed with a goal to embrace the imperfect world that is
the .NET framework in its totality, albeit with an eye for correctness.</p>

<p>At this point, we should acknowledge Anton Tayanovskyy and his great little F#
snippet <a href="http://www.fssnip.net/6u">Union-Friendly Generic Binary Serializer</a>
which served as the initial inspiration for this library.</p>

<h2>Pickler Combinators</h2>

<p>FsPickler is founded on the functional programming notion of picklers and pickler combinators. 
The concept was originally described in Andrew Kennedy's 
<a href="http://research.microsoft.com/pubs/64036/picklercombinators.pdf">Pickler Combinators</a>.
A pickler is essentially the type:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip">
<span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
</pre>
</td>
<td class="snippet"><pre class="fssnip">
<span class="k">type</span> <span onmouseout="hideTip(event, 'fs5', 7)" onmouseover="showTip(event, 'fs5', 7)" class="i">Pickler</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span><span class="o">&gt;</span> <span class="o">=</span>
    {
        <span onmouseout="hideTip(event, 'fs6', 8)" onmouseover="showTip(event, 'fs6', 8)" class="i">Write</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fs7', 9)" onmouseover="showTip(event, 'fs7', 9)" class="i">WriteState</span> <span class="k">-&gt;</span> <span class="o">&#39;</span><span class="i">T</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs8', 10)" onmouseover="showTip(event, 'fs8', 10)" class="i">unit</span>
        <span onmouseout="hideTip(event, 'fs9', 11)" onmouseover="showTip(event, 'fs9', 11)" class="i">Read</span>  <span class="o">:</span> <span onmouseout="hideTip(event, 'fs10', 12)" onmouseover="showTip(event, 'fs10', 12)" class="i">ReadState</span>  <span class="k">-&gt;</span> <span class="o">&#39;</span><span class="i">T</span>
    }</pre>
</td>
</tr>
</table>

<p>The <code>Write</code> and <code>Read</code> functions represent serialization and deserialization 
implementations for values of type <code>'T</code>. When compared to prevailing .NET serialization patterns, 
picklers are exceptionally fast since they directly handle the serialized value
without any reliance on reflection-based resolution.</p>

<p>Pickler combinators are functions that operate on picklers, generating picklers of more complex types. 
For instance, the following could be a pickler combinator implementation for rank-1 arrays:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip">
<span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
</pre>
</td>
<td class="snippet"><pre class="fssnip">
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs11', 13)" onmouseover="showTip(event, 'fs11', 13)" class="i">mkArrayPickler</span> (<span onmouseout="hideTip(event, 'fs12', 14)" onmouseover="showTip(event, 'fs12', 14)" class="i">ip</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fs5', 15)" onmouseover="showTip(event, 'fs5', 15)" class="i">Pickler</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs13', 16)" onmouseover="showTip(event, 'fs13', 16)" class="i">int</span><span class="o">&gt;</span>) (<span onmouseout="hideTip(event, 'fs14', 17)" onmouseover="showTip(event, 'fs14', 17)" class="i">tp</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fs5', 18)" onmouseover="showTip(event, 'fs5', 18)" class="i">Pickler</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span><span class="o">&gt;</span>) <span class="o">:</span> <span onmouseout="hideTip(event, 'fs5', 19)" onmouseover="showTip(event, 'fs5', 19)" class="i">Pickler</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span> []<span class="o">&gt;</span> <span class="o">=</span>
    {
        <span class="i">Write</span> <span class="o">=</span> <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs15', 20)" onmouseover="showTip(event, 'fs15', 20)" class="i">s</span> <span onmouseout="hideTip(event, 'fs16', 21)" onmouseover="showTip(event, 'fs16', 21)" class="i">a</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs12', 22)" onmouseover="showTip(event, 'fs12', 22)" class="i">ip</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs17', 23)" onmouseover="showTip(event, 'fs17', 23)" class="i">Write</span> <span onmouseout="hideTip(event, 'fs15', 24)" onmouseover="showTip(event, 'fs15', 24)" class="i">s</span> <span onmouseout="hideTip(event, 'fs16', 25)" onmouseover="showTip(event, 'fs16', 25)" class="i">a</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs18', 26)" onmouseover="showTip(event, 'fs18', 26)" class="i">Length</span> ; <span onmouseout="hideTip(event, 'fs19', 27)" onmouseover="showTip(event, 'fs19', 27)" class="i">Array</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs20', 28)" onmouseover="showTip(event, 'fs20', 28)" class="i">iter</span> (<span onmouseout="hideTip(event, 'fs14', 29)" onmouseover="showTip(event, 'fs14', 29)" class="i">tp</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs6', 30)" onmouseover="showTip(event, 'fs6', 30)" class="i">Write</span> <span onmouseout="hideTip(event, 'fs15', 31)" onmouseover="showTip(event, 'fs15', 31)" class="i">s</span>) <span onmouseout="hideTip(event, 'fs16', 32)" onmouseover="showTip(event, 'fs16', 32)" class="i">a</span>
        <span class="i">Read</span> <span class="o">=</span> <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs21', 33)" onmouseover="showTip(event, 'fs21', 33)" class="i">s</span> <span class="k">-&gt;</span> <span class="k">let</span> <span onmouseout="hideTip(event, 'fs22', 34)" onmouseover="showTip(event, 'fs22', 34)" class="i">l</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs12', 35)" onmouseover="showTip(event, 'fs12', 35)" class="i">ip</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs23', 36)" onmouseover="showTip(event, 'fs23', 36)" class="i">Read</span> <span onmouseout="hideTip(event, 'fs21', 37)" onmouseover="showTip(event, 'fs21', 37)" class="i">s</span> <span class="k">in</span> <span onmouseout="hideTip(event, 'fs19', 38)" onmouseover="showTip(event, 'fs19', 38)" class="i">Array</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs24', 39)" onmouseover="showTip(event, 'fs24', 39)" class="i">init</span> <span onmouseout="hideTip(event, 'fs22', 40)" onmouseover="showTip(event, 'fs22', 40)" class="i">l</span> (<span class="k">fun</span> _ <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs14', 41)" onmouseover="showTip(event, 'fs14', 41)" class="i">tp</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs9', 42)" onmouseover="showTip(event, 'fs9', 42)" class="i">Read</span> <span onmouseout="hideTip(event, 'fs21', 43)" onmouseover="showTip(event, 'fs21', 43)" class="i">s</span>)
    }</pre>
</td>
</tr>
</table>

<p>Given a sufficient range of primitive picklers and pickler combinators,
it is possible to define pickling rules for most essentially serializable .NET types. 
However, these would still need to be declared manually by their implementor.</p>

<p>FsPickler attempts to solve this by providing an automated pickler generation framework: 
picklers are generated at runtime and on demand using a combination of reflection and 
dynamic IL generation. Picklers are cached for future use, hence the cost of generation 
has a constant price.</p>

<p>Moreover, FsPickler extends the concept of picklers so that features particular to the
.NET framework are accommodated: object orientation and subtype polymorphism, 
null references and cyclic objects.</p>

<p>It should be mentioned for the sake of completeness that a 
<a href="http://lampwww.epfl.ch/~hmiller/files/pickling.pdf">similar effort</a> 
has been undertaken by the Scala community. There are differences of approach however, 
since this mostly relies on the metaprogramming facility offered by scala.</p>

<h2>Serializable Types</h2>

<p>So what qualifies as a serializable type in FsPickler?
The short answer would be any type <code>'T</code> for which we present an instance of <code>Pickler&lt;'T&gt;</code>.
To make the question more meaningful, we should really be asking what types can receive
auto-generated picklers. This is something that can only be answered at runtime,
typically by calling</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip">
<span class="l">1: </span>
</pre>
</td>
<td class="snippet"><pre class="fssnip">
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs25', 46)" onmouseover="showTip(event, 'fs25', 46)" class="i">pickler</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs26', 47)" onmouseover="showTip(event, 'fs26', 47)" class="i">FsPickler</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs27', 48)" onmouseover="showTip(event, 'fs27', 48)" class="i">GeneratePickler</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs4', 49)" onmouseover="showTip(event, 'fs4', 49)" class="i">SomeType</span><span class="o">&gt;</span> ()</pre>
</td>
</tr>
</table>

<p>or by asking</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip">
<span class="l">1: </span>
</pre>
</td>
<td class="snippet"><pre class="fssnip">
<span onmouseout="hideTip(event, 'fs26', 50)" onmouseover="showTip(event, 'fs26', 50)" class="i">FsPickler</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs28', 51)" onmouseover="showTip(event, 'fs28', 51)" class="i">IsSerializableType</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs4', 52)" onmouseover="showTip(event, 'fs4', 52)" class="i">SomeType</span><span class="o">&gt;</span> ()</pre>
</td>
</tr>
</table>

<p>Primitive types and <code>string</code> are serializable but pointers, COM objects and MarshalByRef types are not.
A managed class or struct is serializable if and only if it carries the <code>Serializable</code> attribute
and moreover satisfies either of the following:</p>

<ul>
<li><p>is abstract or a delegate.</p></li>
<li><p>is array/nullable/tuple/enum of serializable element types.</p></li>
<li><p>implements the <code>ISerializable</code> attribute and has a matching constructor implementation.</p></li>
<li><p>carries the <code>DataContract</code> attribute and all designated properties are of 
serializable type and settable. Parameterless constructors or public properties are not required.</p></li>
<li><p>carries the <a href="reference/nessos-fspickler-custompicklerattribute.html"><code>CustomPickler</code></a> attribute and an accompanying pickler factory method.</p></li>
<li>is neither of the above and all designated fields are of serializable type.
Parameterless constructors or public fields are not required.</li>
</ul>

<div class="tip" id="fs1">namespace Nessos</div>
<div class="tip" id="fs2">namespace Nessos.FsPickler</div>
<div class="tip" id="fs3">namespace Nessos.FsPickler.Combinators</div>
<div class="tip" id="fs4">type SomeType<br /><br />Full name: Overview.SomeType</div>
<div class="tip" id="fs5">Multiple items<br />module Pickler<br /><br />from Nessos.FsPickler.Combinators<br /><br />--------------------<br />type Pickler =<br />&#160;&#160;private new : Type -&gt; Pickler<br />&#160;&#160;abstract member private Cast : unit -&gt; Pickler&lt;&#39;S&gt;<br />&#160;&#160;abstract member private Unpack : IPicklerUnpacker&lt;&#39;U&gt; -&gt; &#39;U<br />&#160;&#160;abstract member private UntypedRead : state:ReadState -&gt; tag:string -&gt; obj<br />&#160;&#160;abstract member private UntypedWrite : state:WriteState -&gt; tag:string -&gt; value:obj -&gt; unit<br />&#160;&#160;abstract member ImplementationType : Type<br />&#160;&#160;abstract member IsCacheByRef : bool<br />&#160;&#160;abstract member PicklerInfo : PicklerInfo<br />&#160;&#160;abstract member UseWithSubtypes : bool<br />&#160;&#160;member IsOfFixedSize : bool<br />&#160;&#160;...<br /><br />Full name: Nessos.FsPickler.Pickler<br /><br />--------------------<br />type Pickler&lt;&#39;T&gt; =<br />&#160;&#160;{Write: WriteState -&gt; &#39;T -&gt; unit;<br />&#160;&#160;&#160;Read: ReadState -&gt; &#39;T;}<br /><br />Full name: Overview.Pickler&lt;_&gt;</div>
<div class="tip" id="fs6">Pickler.Write: WriteState -&gt; &#39;T -&gt; unit</div>
<div class="tip" id="fs7">type WriteState =<br />&#160;&#160;private new : formatter:IPickleFormatWriter * resolver:IPicklerResolver * reflectionCache:ReflectionCache * ?streamingContext:StreamingContext * ?visitor:IObjectVisitor -&gt; WriteState<br />&#160;&#160;member private CyclicObjectSet : HashSet&lt;int64&gt;<br />&#160;&#160;member private Formatter : IPickleFormatWriter<br />&#160;&#160;member private ObjectIdGenerator : ObjectIDGenerator<br />&#160;&#160;member private ObjectStack : Stack&lt;int64&gt;<br />&#160;&#160;member private PicklerResolver : IPicklerResolver<br />&#160;&#160;member private ReflectionCache : ReflectionCache<br />&#160;&#160;member StreamingContext : StreamingContext<br />&#160;&#160;member private TypePickler : Pickler&lt;Type&gt;<br />&#160;&#160;member private Visitor : IObjectVisitor option<br /><br />Full name: Nessos.FsPickler.WriteState</div>
<div class="tip" id="fs8">type unit = Unit<br /><br />Full name: Microsoft.FSharp.Core.unit</div>
<div class="tip" id="fs9">Pickler.Read: ReadState -&gt; &#39;T</div>
<div class="tip" id="fs10">type ReadState =<br />&#160;&#160;private new : formatter:IPickleFormatReader * resolver:IPicklerResolver * reflectionCache:ReflectionCache * ?streamingContext:StreamingContext -&gt; ReadState<br />&#160;&#160;member private EarlyRegisterArray : array:Array -&gt; unit<br />&#160;&#160;member private NextObjectId : unit -&gt; int64<br />&#160;&#160;member private Formatter : IPickleFormatReader<br />&#160;&#160;member private ObjectCache : Dictionary&lt;int64,obj&gt;<br />&#160;&#160;member private PicklerResolver : IPicklerResolver<br />&#160;&#160;member private ReflectionCache : ReflectionCache<br />&#160;&#160;member StreamingContext : StreamingContext<br />&#160;&#160;member private TypePickler : Pickler&lt;Type&gt;<br /><br />Full name: Nessos.FsPickler.ReadState</div>
<div class="tip" id="fs11">val mkArrayPickler : ip:Pickler&lt;int&gt; -&gt; tp:Pickler&lt;&#39;T&gt; -&gt; Pickler&lt;&#39;T []&gt;<br /><br />Full name: Overview.mkArrayPickler</div>
<div class="tip" id="fs12">val ip : Pickler&lt;int&gt;</div>
<div class="tip" id="fs13">Multiple items<br />val int : value:&#39;T -&gt; int (requires member op_Explicit)<br /><br />Full name: Microsoft.FSharp.Core.Operators.int<br /><br />--------------------<br />type int = int32<br /><br />Full name: Microsoft.FSharp.Core.int<br /><br />--------------------<br />type int&lt;&#39;Measure&gt; = int<br /><br />Full name: Microsoft.FSharp.Core.int&lt;_&gt;</div>
<div class="tip" id="fs14">val tp : Pickler&lt;&#39;T&gt;</div>
<div class="tip" id="fs15">val s : WriteState</div>
<div class="tip" id="fs16">val a : &#39;T []</div>
<div class="tip" id="fs17">Pickler.Write: WriteState -&gt; int -&gt; unit</div>
<div class="tip" id="fs18">property System.Array.Length: int</div>
<div class="tip" id="fs19">module Array<br /><br />from Microsoft.FSharp.Collections</div>
<div class="tip" id="fs20">val iter : action:(&#39;T -&gt; unit) -&gt; array:&#39;T [] -&gt; unit<br /><br />Full name: Microsoft.FSharp.Collections.Array.iter</div>
<div class="tip" id="fs21">val s : ReadState</div>
<div class="tip" id="fs22">val l : int</div>
<div class="tip" id="fs23">Pickler.Read: ReadState -&gt; int</div>
<div class="tip" id="fs24">val init : count:int -&gt; initializer:(int -&gt; &#39;T) -&gt; &#39;T []<br /><br />Full name: Microsoft.FSharp.Collections.Array.init</div>
<div class="tip" id="fs25">val pickler : Pickler&lt;SomeType&gt;<br /><br />Full name: Overview.pickler</div>
<div class="tip" id="fs26">type FsPickler =<br />&#160;&#160;private new : unit -&gt; FsPickler<br />&#160;&#160;static member Clone : t:&#39;T -&gt; &#39;T<br />&#160;&#160;static member ComputeHash : value:&#39;T * ?hashFactory:IHashStreamFactory -&gt; HashResult<br />&#160;&#160;static member ComputeSize : value:&#39;T -&gt; int64<br />&#160;&#160;static member CreateBinary : ?forceLittleEndian:bool * ?typeConverter:ITypeNameConverter -&gt; BinarySerializer<br />&#160;&#160;static member CreateXml : ?typeConverter:ITypeNameConverter * ?indent:bool -&gt; XmlSerializer<br />&#160;&#160;static member GatherObjectsInGraph : graph:obj -&gt; obj []<br />&#160;&#160;static member GatherTypesInObjectGraph : graph:obj -&gt; Type []<br />&#160;&#160;static member GeneratePickler : unit -&gt; Pickler&lt;&#39;T&gt;<br />&#160;&#160;static member GeneratePickler : t:Type -&gt; Pickler<br />&#160;&#160;...<br /><br />Full name: Nessos.FsPickler.FsPickler</div>
<div class="tip" id="fs27">static member FsPickler.GeneratePickler : unit -&gt; Pickler&lt;&#39;T&gt;<br />static member FsPickler.GeneratePickler : t:System.Type -&gt; Pickler</div>
<div class="tip" id="fs28">static member FsPickler.IsSerializableType : unit -&gt; bool<br />static member FsPickler.IsSerializableType : t:System.Type -&gt; bool</div>

        </div>
        <div class="span3">
          <a target="_blank" href="http://www.nessos.gr/">
			<img src="/FsPickler/img/nessos.png" alt="F# Project" style="width:150px;margin:10px" /> 
		  </a>
          <ul class="nav nav-list" id="menu" style="margin-top: 20px;">
            <li class="nav-header">FsPickler</li>
            <li><a href="/FsPickler/index.html">Home page</a></li>
            <li class="divider"></li>
            <li><a href="http://www.nuget.org/packages/FsPickler">Get Library via NuGet</a></li>
            <li><a href="http://github.com/nessos/FsPickler">Source Code on GitHub</a></li>
            <li><a href="http://github.com/nessos/FsPickler/blob/master/License.md">License</a></li>
            <li><a href="http://github.com/nessos/FsPickler/blob/master/RELEASE_NOTES.md">Release Notes</a></li>

            <li class="nav-header">Documentation</li>
            <li><a href="/FsPickler/tutorial.html">Tutorial</a></li>
            <li><a href="/FsPickler/benchmarks.html">Performance</a></li>
            <li class="divider"></li>
            <li><a href="/FsPickler/overview.html">Technical Overview</a></li>
            <li><a href="/FsPickler/reference/index.html">API Reference</a></li>
          </ul>
        </div>
      </div>
    </div>
    <a href="http://github.com/nessos/FsPickler"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" alt="Fork me on GitHub"/></a>
  </body>
  </html>
