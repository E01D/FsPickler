{"name":"Fspickler","tagline":"A fast binary serializer written in F#","body":"# FsPickler\r\n\r\nA fast, general-purpose binary serializer for .NET written in F# \r\nthat doubles as a pickler combinator library.\r\n\r\n* Based on the notion of pickler combinators.\r\n* Provides an automated, strongly typed, pickler generation framework.\r\n* Full support for .NET types, including classes and open hierarchies.\r\n* Compatible with all serializable types, including the ``ISerializable`` interface.\r\n* Highly optimized for F# core types.\r\n* Performance about 5-20x faster than the default .NET serializers.\r\n* Full support for the mono framework.\r\n\r\nGet the NuGet package [here](https://www.nuget.org/packages/FsPickler/).\r\n\r\n### Basic Usage\r\n\r\nThe following snippet presents the basic serialization/deserialization API for FsPickler:\r\n\r\n```fsharp\r\nopen FsPickler\r\n\r\nlet fsp = new FsPickler()\r\n\r\n// typed serialization\r\nfsp.Serialize<int list option>(stream, Some [1; 2; 3])\r\nfsp.Deserialize<int list option>(stream)\r\n\r\n// typed serialization with explicit pickler use\r\nlet pickler : Pickler<int list option> = fsp.GeneratePickler<int list option> ()\r\n\r\nfsp.Serialize(pickler, stream, Some [1; 2; 3])\r\nfsp.Deserialize(pickler, stream) : int list option\r\n\r\n// untyped serialization\r\nfsp.Serialize(typeof<int>, stream, 42)\r\nfsp.Deserialize(typeof<int>, stream) : obj\r\n\r\n// untyped serialization with explicit pickler use\r\nlet pickler' : Pickler = fsp.GeneratePickler typeof<int>\r\n\r\nfsp.Serialize(pickler', stream, 42)\r\nfsp.Deserializer(pickler', stream) : obj\r\n```\r\n\r\nAll generated picklers are strongly typed; pickling is performed efficiently\r\nwithout intermediate boxings. Picklers are generated at runtime using reflection\r\nand expression trees that are aggressively cached for future use.\r\n\r\n### Pickler Combinators\r\n\r\nFsPickler offers experimental support for generating user-defined picklers using combinators:\r\n\r\n```fsharp\r\nopen FsPickler\r\nopen FsPickler.Combinators\r\n\r\nlet p : Pickler<int * string option> = \r\n    Pickler.string \r\n    |> Pickler.option \r\n    |> Pickler.pair Pickler.int\r\n    \r\nlet data : byte [] = pickle p (42, Some \"\")\r\nunpickle p data\r\n```\r\n\r\nThe combinator library includes all primitives as described in Andrew Kennedy's \r\n[Pickler Combinators](http://research.microsoft.com/en-us/um/people/akenn/fun/picklercombinators.pdf)\r\nsuch as ``wrap`` and ``alt``. Fixpoint combinators for declaring recursive picklers are also available:\r\n```fsharp\r\n// val Pickler.fix : (Pickler<'T> -> Pickler<'T>) -> Pickler<'T>\r\n\r\ntype Peano = Zero | Succ of Peano\r\n\r\nlet pp : Pickler<Peano> =\r\n    Pickler.fix(fun peano ->\r\n        peano\r\n        |> Pickler.option\r\n        |> Pickler.wrap (function None -> Zero | Some p -> Succ p)\r\n                        (function Zero -> None | Succ p -> Some p))\r\n                        \r\nSucc (Succ Zero) |> pickle pp |> unpickle pp\r\n```\r\nThe library comes with ``array``, ``array2D``, ``list``, ``set`` and ``map`` \r\ncombinators that are used to build picklers for the corresponding generic types.\r\nThe ``Pickler.seq`` combinator generates picklers for sequences using eager evaluation of elements.\r\nFinally, ``Pickler.func<'a,'b>`` : ``Pickler<('a -> 'b)>`` instantiates picklers for F# functions.\r\n\r\nWhen it comes to generic types, picklers can be defined using user-defined combinators:\r\n\r\n```fsharp\r\ntype BinTree<'T> = Leaf | Node of 'T * BinTree<'T> list\r\n\r\nlet binTree (ep : Pickler<'T>) =\r\n    Pickler.fix(fun tree ->\r\n        tree\r\n        |> Pickler.list\r\n        |> Pickler.pair ep\r\n        |> Pickler.option\r\n        |> Pickler.wrap (function None -> Leaf | Some (t,c) -> Node(t,c))\r\n                        (function Leaf -> None | Node (t,c) -> Some(t,c)))\r\n                        \r\nNode(2,[]) |> pickle (binTree Pickler.int)\r\n```\r\nor it could be done using automatic resolution of type parameters:\r\n\r\n```fsharp\r\nlet binTree<'T> =\r\n    Pickler.fix(fun tree ->\r\n        tree\r\n        |> Pickler.list\r\n        |> Pickler.pair Pickler.auto<'T>\r\n        |> Pickler.option\r\n        |> Pickler.wrap (function None -> Leaf | Some (t,c) -> Node(t,c))\r\n                        (function Leaf -> None | Node (t,c) -> Some(t,c)))\r\n\r\n\r\nNode([1],[Leaf ; Leaf]) |> pickle binTree\r\n```\r\n\r\n### Experimental N-way Sum and Product Combinators\r\n\r\nN-way sum and product combinators provide an alternative pretty syntax for\r\ndefining picklers over arbitrary discriminated unions and records.  Unfortunately\r\nat the moment the performance of resulting picklers is sub-optimal, this might\r\nimprove in the future.\r\n\r\nThe types involved in the examples are not fit for human consumption, but thankfully\r\nF# infers them automatically. The implementation is total and purely functional,\r\nsee this [gist][nway] for some Coq code used to model these combinators.\r\n\r\n[nway]: https://gist.github.com/toyvo/6834822\r\n\r\n#### Records / Product Types\r\n \r\n```fsharp    \r\ntype Person =\r\n    {\r\n        Address : string\r\n        Age : int\r\n        Name : string\r\n    }\r\n\r\nlet makePerson name age address =\r\n    {\r\n        Address = address\r\n        Age = age\r\n        Name = name\r\n    }\r\n\r\nlet personPickler =\r\n    Pickler.product makePerson\r\n    ^+ Pickler.field (fun p -> p.Name) Pickler.string\r\n    ^+ Pickler.field (fun p -> p.Age) Pickler.int\r\n    ^. Pickler.field (fun p -> p.Address) Pickler.string\r\n```\r\n\r\n#### Unions / Sum Types\r\n\r\n```fsharp\r\ntype U =\r\n| Case1\r\n| Case2 of int\r\n| Case3 of string * int\r\n\r\nlet uPickler =\r\n    Pickler.sum (fun x k1 k2 k3 ->\r\n        match x with\r\n        | Case1 -> k1 ()\r\n        | Case2 x -> k2 x\r\n        | Case3 (x, y) -> k3 (x, y))\r\n    ^+ Pickler.variant Case1\r\n    ^+ Pickler.case Case2 Pickler.int\r\n    ^. Pickler.case Case3 (Pickler.pair Pickler.string Pickler.int)\r\n```\r\n\r\n\r\n### Custom Pickler Declarations\r\n\r\nSince F# lacks mechanisms such as type classes or implicits, \r\npickler resolution can only be performed by means of reflection.\r\nThis is done using the following design pattern:\r\n\r\n```fsharp\r\n[<CustomPickler>]\r\ntype CustomClass<'T> (x : 'T) =\r\n\r\n    member __.Value = x\r\n\r\n    static member CreatePickler (resolver : IPicklerResolver) =\r\n        let ep = resolver.Resolve<'T> ()\r\n        ep |> Pickler.wrap (fun x -> CustomClass(x)) (fun c -> c.Value)\r\n```\r\nThis tells the pickler generator to yield a pickler for the given type\r\nusing that particular factory method. The ``IPicklerResolver`` argument provides\r\na handle to the pickler generator and can be used for recursive types:\r\n```fsharp\r\n[<CustomPickler>]\r\ntype RecursiveClass(?nested : RecursiveClass) =\r\n\r\n    member __.Value = nested\r\n\r\n    static member CreatePickler (resolver : IPicklerResolver) =\r\n        let self = resolver.Resolve<RecursiveClass> ()\r\n        self \r\n        |> Pickler.option \r\n        |> Pickler.wrap (fun x -> RecursiveClass(?nested = x)) (fun rc -> rc.Value)\r\n\r\n\r\nlet p = Pickler.auto<RecursiveClass>\r\n\r\nRecursiveClass(RecursiveClass()) |> pickle p |> unpickle p\r\n```\r\n\r\n### Pluggable Picklers\r\n\r\nWhen in need to define custom serialization rules for elsewhere-defined types, \r\na pluggable pickler mechanism is provided. \r\nSupposing the following custom ``Pickler<int option>``:\r\n```fsharp\r\nlet customOptional = Pickler.FromPrimitives((fun _ -> Some 42), fun _ _ -> ())\r\n```\r\nhow could one plug it into the pickler generator?\r\n```fsharp\r\nlet registry = new CustomPicklerRegistry(\"pickler cache with custom optionals\")\r\n\r\ndo registry.RegisterPickler customOptional\r\n\r\nlet fsp' = new FsPickler(registry)\r\n```\r\nThe above initializes a *new* pickler cache; all picklers generated from that cache\r\nwill adhere to the custom rules:\r\n```fsharp\r\nlet optionlist = fsp'.GeneratePickler<int option list> ()\r\n\r\n// outputs a list of Some 42's\r\n[ for i in 1 .. 100 -> Some i ] |> fsp.Pickle optionlist |> fsp.UnPickle optionlist\r\n```\r\nNote that auto-generated picklers do not support interop between caches:\r\n```fsharp\r\nlet pickler = fsp.GeneratePickler<int list> ()\r\n\r\nfsp'.Pickler pickler [1] // runtime error\r\n```\r\n\r\nCare should be taken that custom ``FsPickler`` instances are treated as singletons;\r\ngenerating arbitrarily many instances might put strain on the runtime, \r\nsince each will initialize a unique cache of picklers and emitted code.\r\n\r\n### Pluggable Generic Picklers\r\n\r\nDefining pluggable picklers for generic types is a bit more involved, \r\nand requires the use of special factory methods that need to be implemented\r\nas instances of the ``IPicklerFactory`` interface. The interface itself\r\ndoes not include any methods but instances need to have implemented a\r\nfactory method with type signature \r\n```fsharp\r\nCreate<'T1,...,'Tn when [constraints]> : IPicklerResolver -> Pickler\r\n```\r\nFor instance, supposing I need to define a custom pickler for F# sets:\r\n```fsharp\r\ntype CustomSet () =\r\n    interface IPicklerFactory\r\n\r\n    member __.Create<'T when 'T : comparison> (resolver : IPicklerResolver) =\r\n        let ep = resolver.Resolve<'T> ()\r\n\r\n        ep |> Pickler.wrap (fun x -> set [x]) (fun s -> Seq.head s)\r\n        \r\ndo customPicklers.RegisterPicklerFactory (new CustomSet())\r\n\r\nlet fsp'' = new FsPickler(customPicklers)\r\n```\r\nI can now combine this rather bad pickler implementation as expected:\r\n```fsharp\r\nlet p = fsp''.GeneratePickler<Set<int> option> ()\r\n\r\n// will return singleton set\r\nSome(set [ 1 .. 1000 ]) |> fsp.Pickle p |> fsp.UnPickle p\r\n```\r\n\r\n### Structural Hashcodes\r\n\r\nFsPickler now offers experimental support for structural, non-cryptographic, hashcode generation:\r\n```fsharp\r\n> fsp.ComputeHash [1 .. 100000] ;;\r\nval it : HashResult =\r\n  {Algorithm = \"MurMur3\";\r\n   Length = 400008L;\r\n   Hash =\r\n    [|52uy; 70uy; 141uy; 214uy; 3uy; 231uy; 11uy; 100uy; 94uy; 250uy; 231uy;\r\n      97uy; 188uy; 215uy; 70uy; 0uy|];}\r\n```\r\nThis will generate a 128-bit structural hashcode based on the [MurMurHash](http://en.wikipedia.org/wiki/MurmurHash) algorithm.\r\nImplementation is memory efficient, since the hashing algorithm is integrated with\r\nthe underlying stream implementation. It is possible for users to define their own hashing\r\nalgorithms by inheriting the special `HashStream` class. \r\n\r\nHashing functionality offered by FsPickler is an ideal replacement to `.GetHashCode()` for\r\nlarge objects or complex object graphs, but it is not recommended for small values or primitives.\r\n\r\nIf a hashcode is not required, the size of an object alone can be computed as follows:\r\n```fsharp\r\n> fsp.ComputeSize [1 .. 1000000] ;;\r\nval it : int64 = 4000008L\r\n```\r\n\r\n\r\n### Future work\r\n\r\n* Support for multiple pickle formats.\r\n* A C# friendly API.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}